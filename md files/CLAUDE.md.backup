# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## üè∑Ô∏è CURRENT VERSION STATUS

**STABLE VERSION:** 1.0 (2025-09-18)
**STATUS:** Production Ready - Rollback Point Available
**LAST VERIFIED:** Server-add-component API fully functional

See `STABLE_VERSION_1.md` for complete rollback instructions and change log.

## üìù COMMUNICATION GUIDELINES

**CRITICAL: Token Conservation**
- **Be Concise**: Provide overviews and change summaries in bullet points
- **Changes Format**: `File: Action - Result` (e.g., `api.php: Added validation - Fixed 400 error`)
- **Overview Format**: List only: affected files, key changes, impact
- **No Repetition**: Don't restate what was asked, just answer directly

## üóÑÔ∏è DATABASE CHANGE PROTOCOL

**MANDATORY: Database Schema Changes**
- **ALWAYS** ask for user confirmation BEFORE implementing ANY database changes
- **NEVER** modify database schema without explicit user approval
- **PROVIDE** database changes in a separate `.sql` file when confirmed
- **FORMAT** SQL file for single execution (all commands in one file)
- **INCLUDE** rollback statements as comments for safety
- **LOCATION** Save ALL SQL migration files in `database/migrations/` folder ONLY

**Database Change Process:**
1. Identify database change needed
2. Ask user for confirmation with brief explanation
3. Wait for user approval
4. Create `.sql` file in `database/migrations/` with:
   - Header comments (date, purpose, tables affected)
   - Main SQL statements
   - Commented rollback statements
   - Summary section documenting changes
5. Provide file path and execution instructions

**Migration File Naming Convention:**
- Format: `{action}_{description}.sql`
- Examples:
  - `create_hbacardinventory.sql`
  - `add_new_motherboards_with_riser_slots.sql`
  - `alter_serverinventory_add_power_metrics.sql`

**Migration File Structure:**
```sql
-- --------------------------------------------------------
--
-- Migration: [Brief Description]
-- Date: YYYY-MM-DD
-- Description: [Detailed description of changes]
--
-- --------------------------------------------------------

-- Main SQL statements here
-- INSERT IGNORE for idempotent data migrations

-- --------------------------------------------------------
-- Summary of changes
-- --------------------------------------------------------
```

**Best Practices:**
- Use `INSERT IGNORE` for data migrations to prevent duplicates
- Make migrations idempotent (can run multiple times safely)
- Include comprehensive comments
- Test on development database first
- Execute migrations in chronological order

## Project Overview

BDC Inventory Management System (IMS) - A complete PHP-based REST API with JWT authentication, role-based access control (ACL), and hardware component management. The project includes server building capabilities with hardware compatibility checking.

## Architecture Overview

**Backend Structure:**
- **API Gateway**: Single entry point at `api/api.php` with routing to specialized modules
- **Authentication**: JWT-based authentication with session management
- **ACL System**: Granular permission system with roles and user assignments
- **Component Management**: Modular CRUD operations for hardware components (CPU, RAM, Storage, NIC, Motherboard, PSU, GPU, Cabinet)
- **Server Builder**: Component compatibility validation and server configuration management
- **Database Models**: Specialized classes for compatibility engine, server configuration, and component management

**HYBRID DATA ARCHITECTURE (CRITICAL):**
- **Database (MySQL)**: Inventory tracking ONLY
  - Stores: UUID, SerialNumber, Status, ServerUUID, DateAdded, LastModified, Notes (~10 fields)
  - Purpose: Track component availability, assignments, and purchase information
  - Goal: Minimize database calls for maximum performance
- **JSON Files (All-JSON/)**: Complete component specifications
  - Stores: socket, TDP, cores, threads, memory support, PCIe lanes, compatibility lists (~50+ fields)
  - Structure: 3-level hierarchy (Brand ‚Üí Family ‚Üí Model with UUIDs)
  - Cached: In-memory via `ComponentDataService` singleton pattern
  - Location: `All-JSON/{component-type}-jsons/{level}.json`
  - Cache Limits: Max 1000 component specs, 200 search results (LRU eviction)
- **Data Flow**:
  1. Query component ‚Üí Database returns UUID, serial, status
  2. Get specifications ‚Üí JSON cache via `ComponentDataService`
  3. Compatibility checks ‚Üí JSON via `DataExtractionUtilities`
  4. Update inventory ‚Üí Database (status changes, assignments)
- **Smart Matching**: When direct UUID match fails, system attempts:
  - Serial number pattern matching
  - Model name extraction from Notes field
  - Fuzzy matching for similar component names
  - Returns match with confidence score (0.0-1.0)

**Key Classes:**
- `ComponentDataService.php`: **PRIMARY** - JSON specification service (singleton, 1hr cache)
- `DataExtractionUtilities.php`: Extract detailed specs from JSON (socket, TDP, PCIe lanes, storage interfaces)
- `QueryModel.php`: Database abstraction layer (inventory tracking ONLY)
- `ACL.php`: Permission and role management system
- `BaseFunctions.php`: Core utility functions and JWT integration
- `JWTHelper.php`: JWT token generation and validation
- `ServerBuilder.php`: Server configuration and component management
- `CompatibilityEngine.php`: Hardware compatibility validation (uses JSON specs)

## Development Commands

**Starting Development Server:**
```bash
# PHP built-in server for API testing
php -S localhost:8000 -t .

# For frontend development (if setting up)
cd ims_frontend
# Initialize package.json first, then install dependencies
```

**Claude Code Permissions:**
```bash
# Allow all permissions for full development access
--dangerously-skip-permissions
```

**Database Operations:**
```bash
# Import current database schema
mysql -u username -p database_name < "shubhams_bdc_ims memory ref.sql"

# Database connection details (update in includes/db_config.php)
# Host: localhost:3306
# Database: shubhams_bdc_ims
# User: shubhams_api
```

**Testing API Endpoints:**

**IMPORTANT: Always use the staging URL for API testing:**
API Base URL: `https://shubham.staging.cloudmate.in/bdc_ims/api/api.php`

```bash
# STEP 1: Authentication - Login to get JWT token
curl -X POST "https://shubham.staging.cloudmate.in/bdc_ims/api/api.php" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "action=auth-login&username=superadmin&password=password"

# Response includes access_token in data.tokens.access_token
# Example: "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."

# STEP 2: Use JWT token for authenticated requests
# Add storage component to server configuration
curl -X POST "https://shubham.staging.cloudmate.in/bdc_ims/api/api.php" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d "action=server-add-component&config_uuid=CONFIG_UUID&component_type=storage&component_uuid=COMPONENT_UUID&quantity=1&slot_position=slot 1&override=false"

# List components (requires JWT token)
curl -X POST "https://shubham.staging.cloudmate.in/bdc_ims/api/api.php" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d "action=cpu-list"

# Working Credentials:
# Username: superadmin
# Password: password
```

**CRITICAL: API Cache Timing**
- After modifying code, wait **30 seconds** before testing to allow server cache to clear
- This applies to ALL code changes affecting API responses
- If you get unexpected errors immediately after code changes, wait and retry

## Configuration Management

**Environment Setup:**
- Configuration uses environment variables loaded from `includes/config.env`
- Database credentials in `includes/db_config.php` (update for local development)
- JWT secrets and application settings in `includes/config.php`

**Key Environment Variables:**
- `JWT_SECRET`: JWT signing key (critical for security)
- `APP_ENV`: Environment mode (development/production)
- `DATABASE_*`: Database connection parameters
- `CORS_ALLOWED_ORIGINS`: Frontend domain allowlist

## API Integration Patterns

**Authentication Flow:**
1. Login via `action=auth-login` to receive JWT token
2. Include `Authorization: Bearer <token>` header in subsequent requests
3. Tokens expire based on `JWT_EXPIRY_HOURS` configuration

**Permission System:**
- Actions require specific permissions (e.g., `cpu.create`, `server.edit`)
- Check user permissions before component operations
- Use ACL methods: `hasPermission()`, `getUserRoles()`, `assignPermission()`

**Component CRUD Pattern:**
- All component types follow consistent naming: `{type}-{action}`
- Actions: `list`, `create`, `edit`, `delete`, `view`
- UUIDs auto-generated for all components
- Status codes: 0=Failed, 1=Available, 2=In Use

## Server Building System

**Compatibility Engine:**
- Hardware compatibility validation between components
- Motherboard socket compatibility with CPUs
- Power supply wattage calculations
- Memory slot and type validation
- **Flexible Component Order**: Components can be added in ANY order (CPU before motherboard, or vice versa)
- Uses `FlexibleCompatibilityValidator` for order-independent validation
- Validates compatibility when second component is added, not first

**Component Integration:**
- Use `ServerBuilder` class for configuration management
- Validate compatibility before adding components
- Track component quantities and configurations
- Generate server specifications and cost estimates
- **Orphaned Record Cleanup**: Automatically detects and removes orphaned configuration entries
- **Duplicate Prevention**: Checks both `server_configuration_components` table and inventory `ServerUUID` field

## Security Considerations

**Authentication & Authorization:**
- JWT tokens for stateless authentication
- Role-based permission system with granular controls
- Input validation and SQL injection prevention via PDO prepared statements
- CORS configuration for cross-origin requests

**Database Security:**
- Parameterized queries throughout codebase
- Connection credentials in separate config files
- Error logging without exposing sensitive information

## Frontend Integration Notes

**API Base URL:** `https://shubham.staging.cloudmate.in/bdc_ims/api/api.php`
**Content Types:** `application/x-www-form-urlencoded` or `application/json`
**Response Format:** Consistent JSON with `success`, `authenticated`, `message`, `timestamp`, and `data` fields

## Database Schema Overview

**Core Inventory Tables:**
- `cpuinventory`: CPU components with specifications and status tracking
- `raminventory`: Memory modules with detailed specifications
- `storageinventory`: Storage devices (HDD, SSD, NVMe)
- `motherboardinventory`: Motherboard components with socket compatibility
- `nicinventory`: Network interface cards and adapters
- `caddyinventory`: Drive caddies and mounting hardware
- `pciecardinventory`: PCIe expansion cards (GPU, RAID cards, etc.)

**Authentication & Authorization:**
- `users`: User accounts with encrypted passwords
- `roles`: Role definitions with descriptions
- `permissions`: Granular permission system
- `user_roles`: User-role assignments
- `role_permissions`: Role-permission mappings
- `jwt_blacklist`: Revoked JWT tokens
- `auth_tokens`: Active authentication tokens
- `refresh_tokens`: Token refresh management

**Server Configuration System:**
- `server_configurations`: Complete server builds with component assignments
- `server_configuration_components`: Individual components within configurations
- `server_configuration_history`: Audit trail of configuration changes
- `server_build_templates`: Predefined server templates
- `server_deployments`: Production deployment tracking

**Compatibility Engine:**
- `component_compatibility`: Component compatibility mappings
- `compatibility_rules`: Validation rules for component combinations
- `compatibility_log`: Compatibility check audit logs
- `component_specifications`: Detailed technical specifications
- `component_usage_tracking`: Component allocation and deployment tracking

**Component Types Available:**
- CPU, RAM, Storage, NIC, Motherboard, Caddy, PCIe Cards, Chassis
- Each type has dedicated inventory table with UUID-based identification
- Serial numbers must be unique across the system
- Status codes: 0=Failed/Decommissioned, 1=Available, 2=In Use
- All components support server assignment via `ServerUUID` field

## Error Handling Patterns

**Consistent API Response Format:**
```json
{
    "success": true|false,
    "authenticated": true|false,
    "message": "Human-readable message",
    "timestamp": "2025-01-XX XX:XX:XX",
    "code": 200|400|401|403|404|500,
    "data": { /* Response data */ }
}
```

**Common HTTP Status Codes:**
- `200`: Success
- `201`: Resource created successfully
- `400`: Bad request (validation error, missing parameters)
- `401`: Unauthorized (invalid/missing JWT token)
- `403`: Forbidden (insufficient permissions)
- `404`: Resource not found
- `500`: Internal server error

**Error Logging:**
- All errors logged to PHP error log via `error_log()`
- Production: Errors hidden from response, only generic message shown
- Development: Detailed error messages in response (configure via `APP_ENV`)

## Common Gotchas and Solutions

**1. Orphaned Server Configuration Components:**
- **Issue**: Component exists in `server_configuration_components` but `ServerUUID` in inventory table doesn't match
- **Solution**: System auto-detects and cleans up orphaned records before adding component
- **Location**: `ServerBuilder::addComponent()` line 80-93

**2. Duplicate Component Prevention:**
- **Issue**: Same component UUID added multiple times to same configuration
- **Solution**: System checks both config table and inventory table before allowing addition
- **Location**: `ServerBuilder::isDuplicateComponent()`

**3. Configuration Status Codes:**
- `0`: Draft (editable)
- `1`: Validated (compatibility checked, editable)
- `2`: Built (physically assembled, limited editing)
- `3`: Finalized (production deployed, read-only)

**4. Component Availability:**
- Check `Status` field: Only components with `Status=1` (Available) can be added to new configurations
- Components with `Status=2` (In Use) are assigned to a server (`ServerUUID` is set)
- Release component: Set `Status=1` and clear `ServerUUID` field

**5. JSON Cache Behavior:**
- JSON files loaded once per component type and cached in memory
- Cache persists for duration of PHP request
- No automatic cache invalidation - restart PHP-FPM to clear cache if JSON files updated
- Manual cache clear: `ComponentDataService::getInstance()->clearCache('cpu')`

**6. Permission Denied Errors:**
- All API operations (except `auth-*`) require valid JWT token
- Each operation requires specific permission (e.g., `cpu.view`, `server.create`)
- Check user permissions: `action=acl-check_permission&permission=cpu.create`
- Assign permissions: Use ACL admin interface or `action=acl-assign_permission`

## Performance Optimization Tips

**1. Minimize Database Queries:**
- Use `ComponentDataService` for component specifications (JSON-based)
- Only query database for inventory tracking (UUID, status, serial number)
- Batch operations when possible

**2. Preload Popular Components:**
```php
$service = ComponentDataService::getInstance();
$service->preloadPopularComponents(['cpu', 'motherboard', 'ram']);
```

**3. Component Lookup Strategy:**
- Direct UUID lookup: Fastest (O(1) with cache)
- Model name search: Moderate (O(n) through JSON)
- Smart matching: Slowest (pattern matching + fuzzy search)